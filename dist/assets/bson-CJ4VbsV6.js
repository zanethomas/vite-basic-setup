import{_ as Yn,__tla as Zn}from"./index-CBlVzyTS.js";let sn,a,q,J,Oe,re,St,F,ee,_,Y,k,D,V,te,Z,s,ie,oe,j,C,R,Nt,Et,Ot,se,xt,$t,It,Kn=Promise.all([(()=>{try{return Zn}catch{}})()]).then(async()=>{var on;function Ae(e){return["[object ArrayBuffer]","[object SharedArrayBuffer]"].includes(Object.prototype.toString.call(e))}function ue(e){return Object.prototype.toString.call(e)==="[object Uint8Array]"}function fe(e){return Object.prototype.toString.call(e)==="[object RegExp]"}function Re(e){return Object.prototype.toString.call(e)==="[object Map]"}function le(e){return Object.prototype.toString.call(e)==="[object Date]"}function z(e,t){return JSON.stringify(e,(r,n)=>typeof n=="bigint"?{$numberLong:`${n}`}:Re(n)?Object.fromEntries(n):n)}function un(e){if(e!=null&&typeof e=="object"&&"stylize"in e&&typeof e.stylize=="function")return e.stylize}let K,ae,he,De,Fe,ze,Me,xe,Je,$e,Ve,Ie,_t,Ce,He,qe,_e,pe,Lt,Le,ke,Pe,ce,Ye,Ue,Ze,Ke,We,Ut,de;K=6,ae=2147483647,he=-2147483648,De=Math.pow(2,63)-1,Fe=-Math.pow(2,63),ze=Math.pow(2,53),Me=-Math.pow(2,53),xe=1,Je=2,$e=3,Ve=4,Ie=5,_t=6,Ce=7,He=8,qe=9,_e=10,pe=11,Lt=12,Le=13,ke=14,Pe=15,ce=16,Ye=17,Ue=18,Ze=19,Ke=255,We=127,Ut=0,de=4,St=Object.freeze({double:1,string:2,object:3,array:4,binData:5,undefined:6,objectId:7,bool:8,date:9,null:10,regex:11,dbPointer:12,javascript:13,symbol:14,javascriptWithScope:15,int:16,timestamp:17,long:18,decimal:19,minKey:-1,maxKey:127}),a=class extends Error{get bsonError(){return!0}get name(){return"BSONError"}constructor(e,t){super(e,t)}static isBSONError(e){return e!=null&&typeof e=="object"&&"bsonError"in e&&e.bsonError===!0&&"name"in e&&"message"in e&&"stack"in e}},ee=class extends a{get name(){return"BSONVersionError"}constructor(){super(`Unsupported BSON version, bson types must be from bson ${K}.x.x`)}},Oe=class extends a{get name(){return"BSONRuntimeError"}constructor(e){super(e)}},q=class extends a{get name(){return"BSONOffsetError"}constructor(e,t,r){super(`${e}. offset: ${t}`,r),this.offset=t}};let Tt,vt;function jt(e,t,r,n){if(n){Tt??(Tt=new TextDecoder("utf8",{fatal:!0}));try{return Tt.decode(e.subarray(t,r))}catch(i){throw new a("Invalid UTF-8 string in BSON document",{cause:i})}}return vt??(vt=new TextDecoder("utf8",{fatal:!1})),vt.decode(e.subarray(t,r))}function At(e,t,r){if(e.length===0)return"";const n=r-t;if(n===0)return"";if(n>20)return null;if(n===1&&e[t]<128)return String.fromCharCode(e[t]);if(n===2&&e[t]<128&&e[t+1]<128)return String.fromCharCode(e[t])+String.fromCharCode(e[t+1]);if(n===3&&e[t]<128&&e[t+1]<128&&e[t+2]<128)return String.fromCharCode(e[t])+String.fromCharCode(e[t+1])+String.fromCharCode(e[t+2]);const i=[];for(let u=t;u<r;u++){const h=e[u];if(h>127)return null;i.push(h)}return String.fromCharCode(...i)}function fn(e,t,r){if(t.length===0)return 0;if(t.length>25||e.length-r<t.length)return null;for(let n=0,i=r;n<t.length;n++,i++){const u=t.charCodeAt(n);if(u>127)return null;e[i]=u}return t.length}function ln(e){return W.fromNumberArray(Array.from({length:e},()=>Math.floor(Math.random()*256)))}const an=await(async()=>{try{return(await Yn(async()=>{const{randomBytes:e}=await Promise.resolve().then(()=>kn);return{randomBytes:e}},void 0)).randomBytes}catch{return ln}})(),W={toLocalBufferType(e){if(Buffer.isBuffer(e))return e;if(ArrayBuffer.isView(e))return Buffer.from(e.buffer,e.byteOffset,e.byteLength);const t=(e==null?void 0:e[Symbol.toStringTag])??Object.prototype.toString.call(e);if(t==="ArrayBuffer"||t==="SharedArrayBuffer"||t==="[object ArrayBuffer]"||t==="[object SharedArrayBuffer]")return Buffer.from(e);throw new a(`Cannot create Buffer from ${String(e)}`)},allocate(e){return Buffer.alloc(e)},allocateUnsafe(e){return Buffer.allocUnsafe(e)},equals(e,t){return W.toLocalBufferType(e).equals(t)},fromNumberArray(e){return Buffer.from(e)},fromBase64(e){return Buffer.from(e,"base64")},toBase64(e){return W.toLocalBufferType(e).toString("base64")},fromISO88591(e){return Buffer.from(e,"binary")},toISO88591(e){return W.toLocalBufferType(e).toString("binary")},fromHex(e){return Buffer.from(e,"hex")},toHex(e){return W.toLocalBufferType(e).toString("hex")},toUTF8(e,t,r,n){const i=r-t<=20?At(e,t,r):null;if(i!=null)return i;const u=W.toLocalBufferType(e).toString("utf8",t,r);if(n){for(let h=0;h<u.length;h++)if(u.charCodeAt(h)===65533){jt(e,t,r,!0);break}}return u},utf8ByteLength(e){return Buffer.byteLength(e,"utf8")},encodeUTF8Into(e,t,r){return fn(e,t,r)??W.toLocalBufferType(e).write(t,r,void 0,"utf8")},randomBytes:an};function hn(){const{navigator:e}=globalThis;return typeof e=="object"&&e.product==="ReactNative"}function cn(e){if(e<0)throw new RangeError(`The argument 'byteLength' is invalid. Received ${e}`);return ye.fromNumberArray(Array.from({length:e},()=>Math.floor(Math.random()*256)))}const gn=(()=>{var t;const{crypto:e}=globalThis;if(e!=null&&typeof e.getRandomValues=="function")return r=>e.getRandomValues(ye.allocate(r));if(hn()){const{console:r}=globalThis;(t=r==null?void 0:r.warn)==null||t.call(r,"BSON: For React Native please polyfill crypto.getRandomValues, e.g. using: https://www.npmjs.com/package/react-native-get-random-values.")}return cn})(),Rt=/(\d|[a-f])/i,ye={toLocalBufferType(e){const t=(e==null?void 0:e[Symbol.toStringTag])??Object.prototype.toString.call(e);if(t==="Uint8Array")return e;if(ArrayBuffer.isView(e))return new Uint8Array(e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength));if(t==="ArrayBuffer"||t==="SharedArrayBuffer"||t==="[object ArrayBuffer]"||t==="[object SharedArrayBuffer]")return new Uint8Array(e);throw new a(`Cannot make a Uint8Array from ${String(e)}`)},allocate(e){if(typeof e!="number")throw new TypeError(`The "size" argument must be of type number. Received ${String(e)}`);return new Uint8Array(e)},allocateUnsafe(e){return ye.allocate(e)},equals(e,t){if(e.byteLength!==t.byteLength)return!1;for(let r=0;r<e.byteLength;r++)if(e[r]!==t[r])return!1;return!0},fromNumberArray(e){return Uint8Array.from(e)},fromBase64(e){return Uint8Array.from(atob(e),t=>t.charCodeAt(0))},toBase64(e){return btoa(ye.toISO88591(e))},fromISO88591(e){return Uint8Array.from(e,t=>t.charCodeAt(0)&255)},toISO88591(e){return Array.from(Uint16Array.from(e),t=>String.fromCharCode(t)).join("")},fromHex(e){const t=e.length%2===0?e:e.slice(0,e.length-1),r=[];for(let n=0;n<t.length;n+=2){const i=t[n],u=t[n+1];if(!Rt.test(i)||!Rt.test(u))break;const h=Number.parseInt(`${i}${u}`,16);r.push(h)}return Uint8Array.from(r)},toHex(e){return Array.from(e,t=>t.toString(16).padStart(2,"0")).join("")},toUTF8(e,t,r,n){return(r-t<=20?At(e,t,r):null)??jt(e,t,r,n)},utf8ByteLength(e){return new TextEncoder().encode(e).byteLength},encodeUTF8Into(e,t,r){const n=new TextEncoder().encode(t);return e.set(n,r),n.byteLength},randomBytes:gn},bn=typeof Buffer=="function"&&((on=Buffer.prototype)==null?void 0:on._isBuffer)!==!0,f=bn?W:ye;F=class{get[Symbol.for("@@mdb.bson.version")](){return K}[Symbol.for("nodejs.util.inspect.custom")](e,t,r){return this.inspect(e,t,r)}},_=class extends F{get _bsontype(){return"Binary"}constructor(e,t){if(super(),e!=null&&typeof e=="string"&&!ArrayBuffer.isView(e)&&!Ae(e)&&!Array.isArray(e))throw new a("Binary can only be constructed from Uint8Array or number[]");this.sub_type=t??_.BSON_BINARY_SUBTYPE_DEFAULT,e==null?(this.buffer=f.allocate(_.BUFFER_SIZE),this.position=0):(this.buffer=Array.isArray(e)?f.fromNumberArray(e):f.toLocalBufferType(e),this.position=this.buffer.byteLength)}put(e){if(typeof e=="string"&&e.length!==1)throw new a("only accepts single character String");if(typeof e!="number"&&e.length!==1)throw new a("only accepts single character Uint8Array or Array");let t;if(typeof e=="string"?t=e.charCodeAt(0):typeof e=="number"?t=e:t=e[0],t<0||t>255)throw new a("only accepts number in a valid unsigned byte range 0-255");if(this.buffer.byteLength>this.position)this.buffer[this.position++]=t;else{const r=f.allocate(_.BUFFER_SIZE+this.buffer.length);r.set(this.buffer,0),this.buffer=r,this.buffer[this.position++]=t}}write(e,t){if(t=typeof t=="number"?t:this.position,this.buffer.byteLength<t+e.length){const r=f.allocate(this.buffer.byteLength+e.length);r.set(this.buffer,0),this.buffer=r}if(ArrayBuffer.isView(e))this.buffer.set(f.toLocalBufferType(e),t),this.position=t+e.byteLength>this.position?t+e.length:this.position;else if(typeof e=="string")throw new a("input cannot be string")}read(e,t){return t=t&&t>0?t:this.position,this.buffer.slice(e,e+t)}value(){return this.buffer.length===this.position?this.buffer:this.buffer.subarray(0,this.position)}length(){return this.position}toJSON(){return f.toBase64(this.buffer.subarray(0,this.position))}toString(e){return e==="hex"?f.toHex(this.buffer.subarray(0,this.position)):e==="base64"?f.toBase64(this.buffer.subarray(0,this.position)):e==="utf8"||e==="utf-8"?f.toUTF8(this.buffer,0,this.position,!1):f.toUTF8(this.buffer,0,this.position,!1)}toExtendedJSON(e){e=e||{};const t=f.toBase64(this.buffer),r=Number(this.sub_type).toString(16);return e.legacy?{$binary:t,$type:r.length===1?"0"+r:r}:{$binary:{base64:t,subType:r.length===1?"0"+r:r}}}toUUID(){if(this.sub_type===_.SUBTYPE_UUID)return new R(this.buffer.slice(0,this.position));throw new a(`Binary sub_type "${this.sub_type}" is not supported for converting to UUID. Only "${_.SUBTYPE_UUID}" is currently supported.`)}static createFromHexString(e,t){return new _(f.fromHex(e),t)}static createFromBase64(e,t){return new _(f.fromBase64(e),t)}static fromExtendedJSON(e,t){t=t||{};let r,n;if("$binary"in e?t.legacy&&typeof e.$binary=="string"&&"$type"in e?(n=e.$type?parseInt(e.$type,16):0,r=f.fromBase64(e.$binary)):typeof e.$binary!="string"&&(n=e.$binary.subType?parseInt(e.$binary.subType,16):0,r=f.fromBase64(e.$binary.base64)):"$uuid"in e&&(n=4,r=R.bytesFromString(e.$uuid)),!r)throw new a(`Unexpected Binary Extended JSON format ${JSON.stringify(e)}`);return n===de?new R(r):new _(r,n)}inspect(e,t,r){r??(r=z);const n=f.toBase64(this.buffer.subarray(0,this.position)),i=r(n,t),u=r(this.sub_type,t);return`Binary.createFromBase64(${i}, ${u})`}},_.BSON_BINARY_SUBTYPE_DEFAULT=0,_.BUFFER_SIZE=256,_.SUBTYPE_DEFAULT=0,_.SUBTYPE_FUNCTION=1,_.SUBTYPE_BYTE_ARRAY=2,_.SUBTYPE_UUID_OLD=3,_.SUBTYPE_UUID=4,_.SUBTYPE_MD5=5,_.SUBTYPE_ENCRYPTED=6,_.SUBTYPE_COLUMN=7,_.SUBTYPE_SENSITIVE=8,_.SUBTYPE_USER_DEFINED=128;const Ge=16,mn=/^[0-9A-F]{32}$/i,pn=/^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i;R=class extends _{constructor(e){let t;if(e==null)t=R.generate();else if(e instanceof R)t=f.toLocalBufferType(new Uint8Array(e.buffer));else if(ArrayBuffer.isView(e)&&e.byteLength===Ge)t=f.toLocalBufferType(e);else if(typeof e=="string")t=R.bytesFromString(e);else throw new a("Argument passed in UUID constructor must be a UUID, a 16 byte Buffer or a 32/36 character hex string (dashes excluded/included, format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx).");super(t,de)}get id(){return this.buffer}set id(e){this.buffer=e}toHexString(e=!0){return e?[f.toHex(this.buffer.subarray(0,4)),f.toHex(this.buffer.subarray(4,6)),f.toHex(this.buffer.subarray(6,8)),f.toHex(this.buffer.subarray(8,10)),f.toHex(this.buffer.subarray(10,16))].join("-"):f.toHex(this.buffer)}toString(e){return e==="hex"?f.toHex(this.id):e==="base64"?f.toBase64(this.id):this.toHexString()}toJSON(){return this.toHexString()}equals(e){if(!e)return!1;if(e instanceof R)return f.equals(e.id,this.id);try{return f.equals(new R(e).id,this.id)}catch{return!1}}toBinary(){return new _(this.id,_.SUBTYPE_UUID)}static generate(){const e=f.randomBytes(Ge);return e[6]=e[6]&15|64,e[8]=e[8]&63|128,e}static isValid(e){return e?typeof e=="string"?R.isValidUUIDString(e):ue(e)?e.byteLength===Ge:e._bsontype==="Binary"&&e.sub_type===this.SUBTYPE_UUID&&e.buffer.byteLength===16:!1}static createFromHexString(e){const t=R.bytesFromString(e);return new R(t)}static createFromBase64(e){return new R(f.fromBase64(e))}static bytesFromString(e){if(!R.isValidUUIDString(e))throw new a("UUID string representation must be 32 hex digits or canonical hyphenated representation");return f.fromHex(e.replace(/-/g,""))}static isValidUUIDString(e){return mn.test(e)||pn.test(e)}inspect(e,t,r){return r??(r=z),`new UUID(${r(this.toHexString(),t)})`}},Y=class extends F{get _bsontype(){return"Code"}constructor(e,t){super(),this.code=e.toString(),this.scope=t??null}toJSON(){return this.scope!=null?{code:this.code,scope:this.scope}:{code:this.code}}toExtendedJSON(){return this.scope?{$code:this.code,$scope:this.scope}:{$code:this.code}}static fromExtendedJSON(e){return new Y(e.$code,e.$scope)}inspect(e,t,r){r??(r=z);let n=r(this.code,t);const i=n.includes(`
`);this.scope!=null&&(n+=`,${i?`
`:" "}${r(this.scope,t)}`);const u=i&&this.scope===null;return`new Code(${i?`
`:""}${n}${u?`
`:""})`}};function Dt(e){return e!=null&&typeof e=="object"&&"$id"in e&&e.$id!=null&&"$ref"in e&&typeof e.$ref=="string"&&(!("$db"in e)||"$db"in e&&typeof e.$db=="string")}k=class extends F{get _bsontype(){return"DBRef"}constructor(e,t,r,n){super();const i=e.split(".");i.length===2&&(r=i.shift(),e=i.shift()),this.collection=e,this.oid=t,this.db=r,this.fields=n||{}}get namespace(){return this.collection}set namespace(e){this.collection=e}toJSON(){const e=Object.assign({$ref:this.collection,$id:this.oid},this.fields);return this.db!=null&&(e.$db=this.db),e}toExtendedJSON(e){e=e||{};let t={$ref:this.collection,$id:this.oid};return e.legacy||(this.db&&(t.$db=this.db),t=Object.assign(t,this.fields)),t}static fromExtendedJSON(e){const t=Object.assign({},e);return delete t.$ref,delete t.$id,delete t.$db,new k(e.$ref,e.$id,e.$db,t)}inspect(e,t,r){r??(r=z);const n=[r(this.namespace,t),r(this.oid,t),...this.db?[r(this.db,t)]:[],...Object.keys(this.fields).length>0?[r(this.fields,t)]:[]];return n[1]=r===z?`new ObjectId(${n[1]})`:n[1],`new DBRef(${n.join(", ")})`}};function Ft(e){if(e==="")return e;let t=0;const r=e[t]==="-",n=e[t]==="+";(n||r)&&(t+=1);let i=!1;for(;t<e.length&&e[t]==="0";++t)i=!0;return i?`${r?"-":""}${e.length===t?"0":e.slice(t)}`:n?e.slice(1):e}function dn(e,t){t=t??10;const r="0123456789abcdefghijklmnopqrstuvwxyz".slice(0,t);return new RegExp(`[^-+${r}]`,"i").test(e)?!1:e}let M;try{M=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}const zt=65536,yn=1<<24,ge=zt*zt,Mt=ge*ge,Jt=Mt/2,Vt={},Ct={},wn=20,Bn=/^(\+?0|(\+|-)?[1-9][0-9]*)$/;s=class extends F{get _bsontype(){return"Long"}get __isLong__(){return!0}constructor(e=0,t,r){super();const n=typeof t=="boolean"?t:!!r,i=typeof t=="number"?t:0,u=typeof e=="string"?s.fromString(e,n):typeof e=="bigint"?s.fromBigInt(e,n):{low:e|0,high:i|0,unsigned:n};this.low=u.low,this.high=u.high,this.unsigned=u.unsigned}static fromBits(e,t,r){return new s(e,t,r)}static fromInt(e,t){let r,n,i;return t?(e>>>=0,(i=0<=e&&e<256)&&(n=Ct[e],n)?n:(r=s.fromBits(e,(e|0)<0?-1:0,!0),i&&(Ct[e]=r),r)):(e|=0,(i=-128<=e&&e<128)&&(n=Vt[e],n)?n:(r=s.fromBits(e,e<0?-1:0,!1),i&&(Vt[e]=r),r))}static fromNumber(e,t){if(isNaN(e))return t?s.UZERO:s.ZERO;if(t){if(e<0)return s.UZERO;if(e>=Mt)return s.MAX_UNSIGNED_VALUE}else{if(e<=-Jt)return s.MIN_VALUE;if(e+1>=Jt)return s.MAX_VALUE}return e<0?s.fromNumber(-e,t).neg():s.fromBits(e%ge|0,e/ge|0,t)}static fromBigInt(e,t){const r=BigInt(4294967295),n=BigInt(32);return new s(Number(e&r),Number(e>>n&r),t)}static _fromString(e,t,r){if(e.length===0)throw new a("empty string");if(r<2||36<r)throw new a("radix");let n;if((n=e.indexOf("-"))>0)throw new a("interior hyphen");if(n===0)return s._fromString(e.substring(1),t,r).neg();const i=s.fromNumber(Math.pow(r,8));let u=s.ZERO;for(let h=0;h<e.length;h+=8){const m=Math.min(8,e.length-h),o=parseInt(e.substring(h,h+m),r);if(m<8){const p=s.fromNumber(Math.pow(r,m));u=u.mul(p).add(s.fromNumber(o))}else u=u.mul(i),u=u.add(s.fromNumber(o))}return u.unsigned=t,u}static fromStringStrict(e,t,r){let n=!1;if(typeof t=="number"?(r=t,t=!1):n=!!t,r??(r=10),e.trim()!==e)throw new a(`Input: '${e}' contains leading and/or trailing whitespace`);if(!dn(e,r))throw new a(`Input: '${e}' contains invalid characters for radix: ${r}`);const i=Ft(e),u=s._fromString(i,n,r);if(u.toString(r).toLowerCase()!==i.toLowerCase())throw new a(`Input: ${e} is not representable as ${u.unsigned?"an unsigned":"a signed"} 64-bit Long ${r!=null?`with radix: ${r}`:""}`);return u}static fromString(e,t,r){let n=!1;return typeof t=="number"?(r=t,t=!1):n=!!t,r??(r=10),e==="NaN"&&r<24||(e==="Infinity"||e==="+Infinity"||e==="-Infinity")&&r<35?s.ZERO:s._fromString(e,n,r)}static fromBytes(e,t,r){return r?s.fromBytesLE(e,t):s.fromBytesBE(e,t)}static fromBytesLE(e,t){return new s(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)}static fromBytesBE(e,t){return new s(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}static isLong(e){return e!=null&&typeof e=="object"&&"__isLong__"in e&&e.__isLong__===!0}static fromValue(e,t){return typeof e=="number"?s.fromNumber(e,t):typeof e=="string"?s.fromString(e,t):s.fromBits(e.low,e.high,typeof t=="boolean"?t:e.unsigned)}add(e){s.isLong(e)||(e=s.fromValue(e));const t=this.high>>>16,r=this.high&65535,n=this.low>>>16,i=this.low&65535,u=e.high>>>16,h=e.high&65535,m=e.low>>>16,o=e.low&65535;let p=0,c=0,l=0,g=0;return g+=i+o,l+=g>>>16,g&=65535,l+=n+m,c+=l>>>16,l&=65535,c+=r+h,p+=c>>>16,c&=65535,p+=t+u,p&=65535,s.fromBits(l<<16|g,p<<16|c,this.unsigned)}and(e){return s.isLong(e)||(e=s.fromValue(e)),s.fromBits(this.low&e.low,this.high&e.high,this.unsigned)}compare(e){if(s.isLong(e)||(e=s.fromValue(e)),this.eq(e))return 0;const t=this.isNegative(),r=e.isNegative();return t&&!r?-1:!t&&r?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1}comp(e){return this.compare(e)}divide(e){if(s.isLong(e)||(e=s.fromValue(e)),e.isZero())throw new a("division by zero");if(M){if(!this.unsigned&&this.high===-2147483648&&e.low===-1&&e.high===-1)return this;const i=(this.unsigned?M.div_u:M.div_s)(this.low,this.high,e.low,e.high);return s.fromBits(i,M.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?s.UZERO:s.ZERO;let t,r,n;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return s.UZERO;if(e.gt(this.shru(1)))return s.UONE;n=s.UZERO}else{if(this.eq(s.MIN_VALUE))return e.eq(s.ONE)||e.eq(s.NEG_ONE)?s.MIN_VALUE:e.eq(s.MIN_VALUE)?s.ONE:(t=this.shr(1).div(e).shl(1),t.eq(s.ZERO)?e.isNegative()?s.ONE:s.NEG_ONE:(r=this.sub(e.mul(t)),n=t.add(r.div(e)),n));if(e.eq(s.MIN_VALUE))return this.unsigned?s.UZERO:s.ZERO;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();n=s.ZERO}for(r=this;r.gte(e);){t=Math.max(1,Math.floor(r.toNumber()/e.toNumber()));const i=Math.ceil(Math.log(t)/Math.LN2),u=i<=48?1:Math.pow(2,i-48);let h=s.fromNumber(t),m=h.mul(e);for(;m.isNegative()||m.gt(r);)t-=u,h=s.fromNumber(t,this.unsigned),m=h.mul(e);h.isZero()&&(h=s.ONE),n=n.add(h),r=r.sub(m)}return n}div(e){return this.divide(e)}equals(e){return s.isLong(e)||(e=s.fromValue(e)),this.unsigned!==e.unsigned&&this.high>>>31===1&&e.high>>>31===1?!1:this.high===e.high&&this.low===e.low}eq(e){return this.equals(e)}getHighBits(){return this.high}getHighBitsUnsigned(){return this.high>>>0}getLowBits(){return this.low}getLowBitsUnsigned(){return this.low>>>0}getNumBitsAbs(){if(this.isNegative())return this.eq(s.MIN_VALUE)?64:this.neg().getNumBitsAbs();const e=this.high!==0?this.high:this.low;let t;for(t=31;t>0&&!(e&1<<t);t--);return this.high!==0?t+33:t+1}greaterThan(e){return this.comp(e)>0}gt(e){return this.greaterThan(e)}greaterThanOrEqual(e){return this.comp(e)>=0}gte(e){return this.greaterThanOrEqual(e)}ge(e){return this.greaterThanOrEqual(e)}isEven(){return(this.low&1)===0}isNegative(){return!this.unsigned&&this.high<0}isOdd(){return(this.low&1)===1}isPositive(){return this.unsigned||this.high>=0}isZero(){return this.high===0&&this.low===0}lessThan(e){return this.comp(e)<0}lt(e){return this.lessThan(e)}lessThanOrEqual(e){return this.comp(e)<=0}lte(e){return this.lessThanOrEqual(e)}modulo(e){if(s.isLong(e)||(e=s.fromValue(e)),M){const t=(this.unsigned?M.rem_u:M.rem_s)(this.low,this.high,e.low,e.high);return s.fromBits(t,M.get_high(),this.unsigned)}return this.sub(this.div(e).mul(e))}mod(e){return this.modulo(e)}rem(e){return this.modulo(e)}multiply(e){if(this.isZero())return s.ZERO;if(s.isLong(e)||(e=s.fromValue(e)),M){const E=M.mul(this.low,this.high,e.low,e.high);return s.fromBits(E,M.get_high(),this.unsigned)}if(e.isZero())return s.ZERO;if(this.eq(s.MIN_VALUE))return e.isOdd()?s.MIN_VALUE:s.ZERO;if(e.eq(s.MIN_VALUE))return this.isOdd()?s.MIN_VALUE:s.ZERO;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(s.TWO_PWR_24)&&e.lt(s.TWO_PWR_24))return s.fromNumber(this.toNumber()*e.toNumber(),this.unsigned);const t=this.high>>>16,r=this.high&65535,n=this.low>>>16,i=this.low&65535,u=e.high>>>16,h=e.high&65535,m=e.low>>>16,o=e.low&65535;let p=0,c=0,l=0,g=0;return g+=i*o,l+=g>>>16,g&=65535,l+=n*o,c+=l>>>16,l&=65535,l+=i*m,c+=l>>>16,l&=65535,c+=r*o,p+=c>>>16,c&=65535,c+=n*m,p+=c>>>16,c&=65535,c+=i*h,p+=c>>>16,c&=65535,p+=t*o+r*m+n*h+i*u,p&=65535,s.fromBits(l<<16|g,p<<16|c,this.unsigned)}mul(e){return this.multiply(e)}negate(){return!this.unsigned&&this.eq(s.MIN_VALUE)?s.MIN_VALUE:this.not().add(s.ONE)}neg(){return this.negate()}not(){return s.fromBits(~this.low,~this.high,this.unsigned)}notEquals(e){return!this.equals(e)}neq(e){return this.notEquals(e)}ne(e){return this.notEquals(e)}or(e){return s.isLong(e)||(e=s.fromValue(e)),s.fromBits(this.low|e.low,this.high|e.high,this.unsigned)}shiftLeft(e){return s.isLong(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?s.fromBits(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):s.fromBits(0,this.low<<e-32,this.unsigned)}shl(e){return this.shiftLeft(e)}shiftRight(e){return s.isLong(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?s.fromBits(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):s.fromBits(this.high>>e-32,this.high>=0?0:-1,this.unsigned)}shr(e){return this.shiftRight(e)}shiftRightUnsigned(e){if(s.isLong(e)&&(e=e.toInt()),e&=63,e===0)return this;{const t=this.high;if(e<32){const r=this.low;return s.fromBits(r>>>e|t<<32-e,t>>>e,this.unsigned)}else return e===32?s.fromBits(t,0,this.unsigned):s.fromBits(t>>>e-32,0,this.unsigned)}}shr_u(e){return this.shiftRightUnsigned(e)}shru(e){return this.shiftRightUnsigned(e)}subtract(e){return s.isLong(e)||(e=s.fromValue(e)),this.add(e.neg())}sub(e){return this.subtract(e)}toInt(){return this.unsigned?this.low>>>0:this.low}toNumber(){return this.unsigned?(this.high>>>0)*ge+(this.low>>>0):this.high*ge+(this.low>>>0)}toBigInt(){return BigInt(this.toString())}toBytes(e){return e?this.toBytesLE():this.toBytesBE()}toBytesLE(){const e=this.high,t=this.low;return[t&255,t>>>8&255,t>>>16&255,t>>>24,e&255,e>>>8&255,e>>>16&255,e>>>24]}toBytesBE(){const e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,e&255,t>>>24,t>>>16&255,t>>>8&255,t&255]}toSigned(){return this.unsigned?s.fromBits(this.low,this.high,!1):this}toString(e){if(e=e||10,e<2||36<e)throw new a("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(s.MIN_VALUE)){const i=s.fromNumber(e),u=this.div(i),h=u.mul(i).sub(this);return u.toString(e)+h.toInt().toString(e)}else return"-"+this.neg().toString(e);const t=s.fromNumber(Math.pow(e,6),this.unsigned);let r=this,n="";for(;;){const i=r.div(t);let u=(r.sub(i.mul(t)).toInt()>>>0).toString(e);if(r=i,r.isZero())return u+n;for(;u.length<6;)u="0"+u;n=""+u+n}}toUnsigned(){return this.unsigned?this:s.fromBits(this.low,this.high,!0)}xor(e){return s.isLong(e)||(e=s.fromValue(e)),s.fromBits(this.low^e.low,this.high^e.high,this.unsigned)}eqz(){return this.isZero()}le(e){return this.lessThanOrEqual(e)}toExtendedJSON(e){return e&&e.relaxed?this.toNumber():{$numberLong:this.toString()}}static fromExtendedJSON(e,t){const{useBigInt64:r=!1,relaxed:n=!0}={...t};if(e.$numberLong.length>wn)throw new a("$numberLong string is too long");if(!Bn.test(e.$numberLong))throw new a(`$numberLong string "${e.$numberLong}" is in an invalid format`);if(r){const u=BigInt(e.$numberLong);return BigInt.asIntN(64,u)}const i=s.fromString(e.$numberLong);return n?i.toNumber():i}inspect(e,t,r){r??(r=z);const n=r(this.toString(),t),i=this.unsigned?`, ${r(this.unsigned,t)}`:"";return`new Long(${n}${i})`}},s.TWO_PWR_24=s.fromInt(yn),s.MAX_UNSIGNED_VALUE=s.fromBits(-1,-1,!0),s.ZERO=s.fromInt(0),s.UZERO=s.fromInt(0,!0),s.ONE=s.fromInt(1),s.UONE=s.fromInt(1,!0),s.NEG_ONE=s.fromInt(-1),s.MAX_VALUE=s.fromBits(-1,2147483647,!1),s.MIN_VALUE=s.fromBits(0,-2147483648,!1);const Sn=/^(\+|-)?(\d+|(\d*\.\d*))?(E|e)?([-+])?(\d+)?$/,Nn=/^(\+|-)?(Infinity|inf)$/i,En=/^(\+|-)?NaN$/i,be=6111,we=-6176,Ht=6176,qt=34,Xe=f.fromNumberArray([124,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0].reverse()),kt=f.fromNumberArray([248,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0].reverse()),Pt=f.fromNumberArray([120,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0].reverse()),On=/^([-+])?(\d+)?$/,xn=31,Yt=16383,$n=30,In=31;function Zt(e){return!isNaN(parseInt(e,10))}function _n(e){const t=s.fromNumber(1e9);let r=s.fromNumber(0);if(!e.parts[0]&&!e.parts[1]&&!e.parts[2]&&!e.parts[3])return{quotient:e,rem:r};for(let n=0;n<=3;n++)r=r.shiftLeft(32),r=r.add(new s(e.parts[n],0)),e.parts[n]=r.div(t).low,r=r.modulo(t);return{quotient:e,rem:r}}function Ln(e,t){if(!e&&!t)return{high:s.fromNumber(0),low:s.fromNumber(0)};const r=e.shiftRightUnsigned(32),n=new s(e.getLowBits(),0),i=t.shiftRightUnsigned(32),u=new s(t.getLowBits(),0);let h=r.multiply(i),m=r.multiply(u);const o=n.multiply(i);let p=n.multiply(u);return h=h.add(m.shiftRightUnsigned(32)),m=new s(m.getLowBits(),0).add(o).add(p.shiftRightUnsigned(32)),h=h.add(m.shiftRightUnsigned(32)),p=m.shiftLeft(32).add(new s(p.getLowBits(),0)),{high:h,low:p}}function Un(e,t){const r=e.high>>>0,n=t.high>>>0;if(r<n)return!0;if(r===n){const i=e.low>>>0,u=t.low>>>0;if(i<u)return!0}return!1}function H(e,t){throw new a(`"${e}" is not a valid Decimal128 string - ${t}`)}D=class extends F{get _bsontype(){return"Decimal128"}constructor(e){if(super(),typeof e=="string")this.bytes=D.fromString(e).bytes;else if(ue(e)){if(e.byteLength!==16)throw new a("Decimal128 must take a Buffer of 16 bytes");this.bytes=e}else throw new a("Decimal128 must take a Buffer or string")}static fromString(e){return D._fromString(e,{allowRounding:!1})}static fromStringWithRounding(e){return D._fromString(e,{allowRounding:!0})}static _fromString(e,t){let r=!1,n=!1,i=!1,u=!1,h=0,m=0,o=0,p=0,c=0;const l=[0];let g=0,E=0,b=0,x=0,A=new s(0,0),v=new s(0,0),L=0,N=0;if(e.length>=7e3)throw new a(""+e+" not a valid Decimal128 string");const X=e.match(Sn),Ne=e.match(Nn),$=e.match(En);if(!X&&!Ne&&!$||e.length===0)throw new a(""+e+" not a valid Decimal128 string");if(X){const y=X[2],d=X[4],B=X[5],O=X[6];d&&O===void 0&&H(e,"missing exponent power"),d&&y===void 0&&H(e,"missing exponent base"),d===void 0&&(B||O)&&H(e,"missing e before exponent")}if((e[N]==="+"||e[N]==="-")&&(n=!0,r=e[N++]==="-"),!Zt(e[N])&&e[N]!=="."){if(e[N]==="i"||e[N]==="I")return new D(r?kt:Pt);if(e[N]==="N")return new D(Xe)}for(;Zt(e[N])||e[N]===".";){if(e[N]==="."){i&&H(e,"contains multiple periods"),i=!0,N=N+1;continue}g<qt&&(e[N]!=="0"||u)&&(u||(c=m),u=!0,l[E++]=parseInt(e[N],10),g=g+1),u&&(o=o+1),i&&(p=p+1),m=m+1,N=N+1}if(i&&!m)throw new a(""+e+" not a valid Decimal128 string");if(e[N]==="e"||e[N]==="E"){const y=e.substr(++N).match(On);if(!y||!y[2])return new D(Xe);x=parseInt(y[0],10),N=N+y[0].length}if(e[N])return new D(Xe);if(!g)l[0]=0,o=1,g=1,h=0;else if(b=g-1,h=o,h!==1)for(;e[c+h-1+Number(n)+Number(i)]==="0";)h=h-1;for(x<=p&&p>x+16384?x=we:x=x-p;x>be;){if(b=b+1,b>=qt){if(h===0){x=be;break}H(e,"overflow")}x=x-1}if(t.allowRounding){for(;x<we||g<o;){if(b===0&&h<g){x=we,h=0;break}if(g<o?o=o-1:b=b-1,x<be)x=x+1;else{if(l.join("").match(/^0+$/)){x=be;break}H(e,"overflow")}}if(b+1<h){let y=m;i&&(c=c+1,y=y+1),n&&(c=c+1,y=y+1);const d=parseInt(e[c+b+1],10);let B=0;if(d>=5&&(B=1,d===5)){B=l[b]%2===1?1:0;for(let O=c+b+2;O<y;O++)if(parseInt(e[O],10)){B=1;break}}if(B){let O=b;for(;O>=0&&++l[O]>9;O--)if(l[O]=0,O===0)if(x<be)x=x+1,l[O]=1;else return new D(r?kt:Pt)}}}else{for(;x<we||g<o;){if(b===0){if(h===0){x=we;break}H(e,"exponent underflow")}g<o?(e[o-1+Number(n)+Number(i)]!=="0"&&h!==0&&H(e,"inexact rounding"),o=o-1):(l[b]!==0&&H(e,"inexact rounding"),b=b-1),x<be?x=x+1:H(e,"overflow")}b+1<h&&(i&&(c=c+1),n&&(c=c+1),parseInt(e[c+b+1],10)!==0&&H(e,"inexact rounding"))}if(A=s.fromNumber(0),v=s.fromNumber(0),h===0)A=s.fromNumber(0),v=s.fromNumber(0);else if(b<17){let y=0;for(v=s.fromNumber(l[y++]),A=new s(0,0);y<=b;y++)v=v.multiply(s.fromNumber(10)),v=v.add(s.fromNumber(l[y]))}else{let y=0;for(A=s.fromNumber(l[y++]);y<=b-17;y++)A=A.multiply(s.fromNumber(10)),A=A.add(s.fromNumber(l[y]));for(v=s.fromNumber(l[y++]);y<=b;y++)v=v.multiply(s.fromNumber(10)),v=v.add(s.fromNumber(l[y]))}const w=Ln(A,s.fromString("100000000000000000"));w.low=w.low.add(v),Un(w.low,v)&&(w.high=w.high.add(s.fromNumber(1))),L=x+Ht;const I={low:s.fromNumber(0),high:s.fromNumber(0)};w.high.shiftRightUnsigned(49).and(s.fromNumber(1)).equals(s.fromNumber(1))?(I.high=I.high.or(s.fromNumber(3).shiftLeft(61)),I.high=I.high.or(s.fromNumber(L).and(s.fromNumber(16383).shiftLeft(47))),I.high=I.high.or(w.high.and(s.fromNumber(0x7fffffffffff)))):(I.high=I.high.or(s.fromNumber(L&16383).shiftLeft(49)),I.high=I.high.or(w.high.and(s.fromNumber(562949953421311)))),I.low=w.low,r&&(I.high=I.high.or(s.fromString("9223372036854775808")));const T=f.allocateUnsafe(16);return N=0,T[N++]=I.low.low&255,T[N++]=I.low.low>>8&255,T[N++]=I.low.low>>16&255,T[N++]=I.low.low>>24&255,T[N++]=I.low.high&255,T[N++]=I.low.high>>8&255,T[N++]=I.low.high>>16&255,T[N++]=I.low.high>>24&255,T[N++]=I.high.low&255,T[N++]=I.high.low>>8&255,T[N++]=I.high.low>>16&255,T[N++]=I.high.low>>24&255,T[N++]=I.high.high&255,T[N++]=I.high.high>>8&255,T[N++]=I.high.high>>16&255,T[N++]=I.high.high>>24&255,new D(T)}toString(){let e,t=0;const r=new Array(36);for(let L=0;L<r.length;L++)r[L]=0;let n=0,i=!1,u,h={parts:[0,0,0,0]},m,o;const p=[];n=0;const c=this.bytes,l=c[n++]|c[n++]<<8|c[n++]<<16|c[n++]<<24,g=c[n++]|c[n++]<<8|c[n++]<<16|c[n++]<<24,E=c[n++]|c[n++]<<8|c[n++]<<16|c[n++]<<24,b=c[n++]|c[n++]<<8|c[n++]<<16|c[n++]<<24;n=0,{low:new s(l,g),high:new s(E,b)}.high.lessThan(s.ZERO)&&p.push("-");const x=b>>26&xn;if(x>>3===3){if(x===$n)return p.join("")+"Infinity";if(x===In)return"NaN";e=b>>15&Yt,u=8+(b>>14&1)}else u=b>>14&7,e=b>>17&Yt;const A=e-Ht;if(h.parts[0]=(b&16383)+((u&15)<<14),h.parts[1]=E,h.parts[2]=g,h.parts[3]=l,h.parts[0]===0&&h.parts[1]===0&&h.parts[2]===0&&h.parts[3]===0)i=!0;else for(o=3;o>=0;o--){let L=0;const N=_n(h);if(h=N.quotient,L=N.rem.low,!!L)for(m=8;m>=0;m--)r[o*9+m]=L%10,L=Math.floor(L/10)}if(i)t=1,r[n]=0;else for(t=36;!r[n];)t=t-1,n=n+1;const v=t-1+A;if(v>=34||v<=-7||A>0){if(t>34)return p.push("0"),A>0?p.push(`E+${A}`):A<0&&p.push(`E${A}`),p.join("");p.push(`${r[n++]}`),t=t-1,t&&p.push(".");for(let L=0;L<t;L++)p.push(`${r[n++]}`);p.push("E"),v>0?p.push(`+${v}`):p.push(`${v}`)}else if(A>=0)for(let L=0;L<t;L++)p.push(`${r[n++]}`);else{let L=t+A;if(L>0)for(let N=0;N<L;N++)p.push(`${r[n++]}`);else p.push("0");for(p.push(".");L++<0;)p.push("0");for(let N=0;N<t-Math.max(L-1,0);N++)p.push(`${r[n++]}`)}return p.join("")}toJSON(){return{$numberDecimal:this.toString()}}toExtendedJSON(){return{$numberDecimal:this.toString()}}static fromExtendedJSON(e){return D.fromString(e.$numberDecimal)}inspect(e,t,r){return r??(r=z),`new Decimal128(${r(this.toString(),t)})`}},V=class extends F{get _bsontype(){return"Double"}constructor(e){super(),e instanceof Number&&(e=e.valueOf()),this.value=+e}static fromString(e){const t=Number(e);if(e==="NaN")return new V(NaN);if(e==="Infinity")return new V(1/0);if(e==="-Infinity")return new V(-1/0);if(!Number.isFinite(t))throw new a(`Input: ${e} is not representable as a Double`);if(e.trim()!==e)throw new a(`Input: '${e}' contains whitespace`);if(e==="")throw new a("Input is an empty string");if(/[^-0-9.+eE]/.test(e))throw new a(`Input: '${e}' is not in decimal or exponential notation`);return new V(t)}valueOf(){return this.value}toJSON(){return this.value}toString(e){return this.value.toString(e)}toExtendedJSON(e){return e&&(e.legacy||e.relaxed&&isFinite(this.value))?this.value:Object.is(Math.sign(this.value),-0)?{$numberDouble:"-0.0"}:{$numberDouble:Number.isInteger(this.value)?this.value.toFixed(1):this.value.toString()}}static fromExtendedJSON(e,t){const r=parseFloat(e.$numberDouble);return t&&t.relaxed?r:new V(r)}inspect(e,t,r){return r??(r=z),`new Double(${r(this.value,t)})`}},Z=class extends F{get _bsontype(){return"Int32"}constructor(e){super(),e instanceof Number&&(e=e.valueOf()),this.value=+e|0}static fromString(e){const t=Ft(e),r=Number(e);if(ae<r)throw new a(`Input: '${e}' is larger than the maximum value for Int32`);if(he>r)throw new a(`Input: '${e}' is smaller than the minimum value for Int32`);if(Number.isSafeInteger(r)){if(r.toString()!==t)throw new a(`Input: '${e}' is not a valid Int32 string`)}else throw new a(`Input: '${e}' is not a safe integer`);return new Z(r)}valueOf(){return this.value}toString(e){return this.value.toString(e)}toJSON(){return this.value}toExtendedJSON(e){return e&&(e.relaxed||e.legacy)?this.value:{$numberInt:this.value.toString()}}static fromExtendedJSON(e,t){return t&&t.relaxed?parseInt(e.$numberInt,10):new Z(e.$numberInt)}inspect(e,t,r){return r??(r=z),`new Int32(${r(this.value,t)})`}},ie=class extends F{get _bsontype(){return"MaxKey"}toExtendedJSON(){return{$maxKey:1}}static fromExtendedJSON(){return new ie}inspect(){return"new MaxKey()"}},oe=class extends F{get _bsontype(){return"MinKey"}toExtendedJSON(){return{$minKey:1}}static fromExtendedJSON(){return new oe}inspect(){return"new MinKey()"}};const me=new Float64Array(1),U=new Uint8Array(me.buffer,0,8);me[0]=-1;const Kt=U[7]===0,S={getNonnegativeInt32LE(e,t){if(e[t+3]>127)throw new RangeError(`Size cannot be negative at offset: ${t}`);return e[t]|e[t+1]<<8|e[t+2]<<16|e[t+3]<<24},getInt32LE(e,t){return e[t]|e[t+1]<<8|e[t+2]<<16|e[t+3]<<24},getUint32LE(e,t){return e[t]+e[t+1]*256+e[t+2]*65536+e[t+3]*16777216},getUint32BE(e,t){return e[t+3]+e[t+2]*256+e[t+1]*65536+e[t]*16777216},getBigInt64LE(e,t){const r=S.getUint32LE(e,t),n=S.getUint32LE(e,t+4);return(BigInt(n)<<BigInt(32))+BigInt(r)},getFloat64LE:Kt?(e,t)=>(U[7]=e[t],U[6]=e[t+1],U[5]=e[t+2],U[4]=e[t+3],U[3]=e[t+4],U[2]=e[t+5],U[1]=e[t+6],U[0]=e[t+7],me[0]):(e,t)=>(U[0]=e[t],U[1]=e[t+1],U[2]=e[t+2],U[3]=e[t+3],U[4]=e[t+4],U[5]=e[t+5],U[6]=e[t+6],U[7]=e[t+7],me[0]),setInt32BE(e,t,r){return e[t+3]=r,r>>>=8,e[t+2]=r,r>>>=8,e[t+1]=r,r>>>=8,e[t]=r,4},setInt32LE(e,t,r){return e[t]=r,r>>>=8,e[t+1]=r,r>>>=8,e[t+2]=r,r>>>=8,e[t+3]=r,4},setBigInt64LE(e,t,r){const n=BigInt(4294967295);let i=Number(r&n);e[t]=i,i>>=8,e[t+1]=i,i>>=8,e[t+2]=i,i>>=8,e[t+3]=i;let u=Number(r>>BigInt(32)&n);return e[t+4]=u,u>>=8,e[t+5]=u,u>>=8,e[t+6]=u,u>>=8,e[t+7]=u,8},setFloat64LE:Kt?(e,t,r)=>(me[0]=r,e[t]=U[7],e[t+1]=U[6],e[t+2]=U[5],e[t+3]=U[4],e[t+4]=U[3],e[t+5]=U[2],e[t+6]=U[1],e[t+7]=U[0],8):(e,t,r)=>(me[0]=r,e[t]=U[0],e[t+1]=U[1],e[t+2]=U[2],e[t+3]=U[3],e[t+4]=U[4],e[t+5]=U[5],e[t+6]=U[6],e[t+7]=U[7],8)},Tn=new RegExp("^[0-9a-fA-F]{24}$");let ne=null;j=class extends F{get _bsontype(){return"ObjectId"}constructor(e){super();let t;if(typeof e=="object"&&e&&"id"in e){if(typeof e.id!="string"&&!ArrayBuffer.isView(e.id))throw new a("Argument passed in must have an id that is of type string or Buffer");"toHexString"in e&&typeof e.toHexString=="function"?t=f.fromHex(e.toHexString()):t=e.id}else t=e;if(t==null||typeof t=="number")this.buffer=j.generate(typeof t=="number"?t:void 0);else if(ArrayBuffer.isView(t)&&t.byteLength===12)this.buffer=f.toLocalBufferType(t);else if(typeof t=="string")if(t.length===24&&Tn.test(t))this.buffer=f.fromHex(t);else throw new a("input must be a 24 character hex string, 12 byte Uint8Array, or an integer");else throw new a("Argument passed in does not match the accepted types");j.cacheHexString&&(this.__id=f.toHex(this.id))}get id(){return this.buffer}set id(e){this.buffer=e,j.cacheHexString&&(this.__id=f.toHex(e))}toHexString(){if(j.cacheHexString&&this.__id)return this.__id;const e=f.toHex(this.id);return j.cacheHexString&&!this.__id&&(this.__id=e),e}static getInc(){return j.index=(j.index+1)%16777215}static generate(e){typeof e!="number"&&(e=Math.floor(Date.now()/1e3));const t=j.getInc(),r=f.allocateUnsafe(12);return S.setInt32BE(r,0,e),ne===null&&(ne=f.randomBytes(5)),r[4]=ne[0],r[5]=ne[1],r[6]=ne[2],r[7]=ne[3],r[8]=ne[4],r[11]=t&255,r[10]=t>>8&255,r[9]=t>>16&255,r}toString(e){return e==="base64"?f.toBase64(this.id):e==="hex"?this.toHexString():this.toHexString()}toJSON(){return this.toHexString()}static is(e){return e!=null&&typeof e=="object"&&"_bsontype"in e&&e._bsontype==="ObjectId"}equals(e){if(e==null)return!1;if(j.is(e))return this.buffer[11]===e.buffer[11]&&f.equals(this.buffer,e.buffer);if(typeof e=="string")return e.toLowerCase()===this.toHexString();if(typeof e=="object"&&typeof e.toHexString=="function"){const t=e.toHexString(),r=this.toHexString();return typeof t=="string"&&t.toLowerCase()===r}return!1}getTimestamp(){const e=new Date,t=S.getUint32BE(this.buffer,0);return e.setTime(Math.floor(t)*1e3),e}static createPk(){return new j}serializeInto(e,t){return e[t]=this.buffer[0],e[t+1]=this.buffer[1],e[t+2]=this.buffer[2],e[t+3]=this.buffer[3],e[t+4]=this.buffer[4],e[t+5]=this.buffer[5],e[t+6]=this.buffer[6],e[t+7]=this.buffer[7],e[t+8]=this.buffer[8],e[t+9]=this.buffer[9],e[t+10]=this.buffer[10],e[t+11]=this.buffer[11],12}static createFromTime(e){const t=f.allocate(12);for(let r=11;r>=4;r--)t[r]=0;return S.setInt32BE(t,0,e),new j(t)}static createFromHexString(e){if((e==null?void 0:e.length)!==24)throw new a("hex string must be 24 characters");return new j(f.fromHex(e))}static createFromBase64(e){if((e==null?void 0:e.length)!==16)throw new a("base64 string must be 16 characters");return new j(f.fromBase64(e))}static isValid(e){if(e==null)return!1;try{return new j(e),!0}catch{return!1}}toExtendedJSON(){return this.toHexString?{$oid:this.toHexString()}:{$oid:this.toString("hex")}}static fromExtendedJSON(e){return new j(e.$oid)}inspect(e,t,r){return r??(r=z),`new ObjectId(${r(this.toHexString(),t)})`}},j.index=Math.floor(Math.random()*16777215);function Te(e,t,r){let n=5;if(Array.isArray(e))for(let i=0;i<e.length;i++)n+=Wt(i.toString(),e[i],t,!0,r);else{typeof(e==null?void 0:e.toBSON)=="function"&&(e=e.toBSON());for(const i of Object.keys(e))n+=Wt(i,e[i],t,!1,r)}return n}function Wt(e,t,r=!1,n=!1,i=!1){switch(typeof(t==null?void 0:t.toBSON)=="function"&&(t=t.toBSON()),typeof t){case"string":return 1+f.utf8ByteLength(e)+1+4+f.utf8ByteLength(t)+1;case"number":return Math.floor(t)===t&&t>=Me&&t<=ze&&t>=he&&t<=ae?(e!=null?f.utf8ByteLength(e)+1:0)+5:(e!=null?f.utf8ByteLength(e)+1:0)+9;case"undefined":return n||!i?(e!=null?f.utf8ByteLength(e)+1:0)+1:0;case"boolean":return(e!=null?f.utf8ByteLength(e)+1:0)+2;case"object":if(t!=null&&typeof t._bsontype=="string"&&t[Symbol.for("@@mdb.bson.version")]!==K)throw new ee;if(t==null||t._bsontype==="MinKey"||t._bsontype==="MaxKey")return(e!=null?f.utf8ByteLength(e)+1:0)+1;if(t._bsontype==="ObjectId")return(e!=null?f.utf8ByteLength(e)+1:0)+13;if(t instanceof Date||le(t))return(e!=null?f.utf8ByteLength(e)+1:0)+9;if(ArrayBuffer.isView(t)||t instanceof ArrayBuffer||Ae(t))return(e!=null?f.utf8ByteLength(e)+1:0)+6+t.byteLength;if(t._bsontype==="Long"||t._bsontype==="Double"||t._bsontype==="Timestamp")return(e!=null?f.utf8ByteLength(e)+1:0)+9;if(t._bsontype==="Decimal128")return(e!=null?f.utf8ByteLength(e)+1:0)+17;if(t._bsontype==="Code")return t.scope!=null&&Object.keys(t.scope).length>0?(e!=null?f.utf8ByteLength(e)+1:0)+1+4+4+f.utf8ByteLength(t.code.toString())+1+Te(t.scope,r,i):(e!=null?f.utf8ByteLength(e)+1:0)+1+4+f.utf8ByteLength(t.code.toString())+1;if(t._bsontype==="Binary"){const u=t;return u.sub_type===_.SUBTYPE_BYTE_ARRAY?(e!=null?f.utf8ByteLength(e)+1:0)+(u.position+1+4+1+4):(e!=null?f.utf8ByteLength(e)+1:0)+(u.position+1+4+1)}else{if(t._bsontype==="Symbol")return(e!=null?f.utf8ByteLength(e)+1:0)+f.utf8ByteLength(t.value)+4+1+1;if(t._bsontype==="DBRef"){const u=Object.assign({$ref:t.collection,$id:t.oid},t.fields);return t.db!=null&&(u.$db=t.db),(e!=null?f.utf8ByteLength(e)+1:0)+1+Te(u,r,i)}else return t instanceof RegExp||fe(t)?(e!=null?f.utf8ByteLength(e)+1:0)+1+f.utf8ByteLength(t.source)+1+(t.global?1:0)+(t.ignoreCase?1:0)+(t.multiline?1:0)+1:t._bsontype==="BSONRegExp"?(e!=null?f.utf8ByteLength(e)+1:0)+1+f.utf8ByteLength(t.pattern)+1+f.utf8ByteLength(t.options)+1:(e!=null?f.utf8ByteLength(e)+1:0)+Te(t,r,i)+1}case"function":if(r)return(e!=null?f.utf8ByteLength(e)+1:0)+1+4+f.utf8ByteLength(t.toString())+1}return 0}function vn(e){return e.split("").sort().join("")}J=class extends F{get _bsontype(){return"BSONRegExp"}constructor(e,t){if(super(),this.pattern=e,this.options=vn(t??""),this.pattern.indexOf("\0")!==-1)throw new a(`BSON Regex patterns cannot contain null bytes, found: ${JSON.stringify(this.pattern)}`);if(this.options.indexOf("\0")!==-1)throw new a(`BSON Regex options cannot contain null bytes, found: ${JSON.stringify(this.options)}`);for(let r=0;r<this.options.length;r++)if(!(this.options[r]==="i"||this.options[r]==="m"||this.options[r]==="x"||this.options[r]==="l"||this.options[r]==="s"||this.options[r]==="u"))throw new a(`The regular expression option [${this.options[r]}] is not supported`)}static parseOptions(e){return e?e.split("").sort().join(""):""}toExtendedJSON(e){return e=e||{},e.legacy?{$regex:this.pattern,$options:this.options}:{$regularExpression:{pattern:this.pattern,options:this.options}}}static fromExtendedJSON(e){if("$regex"in e)if(typeof e.$regex!="string"){if(e.$regex._bsontype==="BSONRegExp")return e}else return new J(e.$regex,J.parseOptions(e.$options));if("$regularExpression"in e)return new J(e.$regularExpression.pattern,J.parseOptions(e.$regularExpression.options));throw new a(`Unexpected BSONRegExp EJSON object form: ${JSON.stringify(e)}`)}inspect(e,t,r){const n=un(t)??(h=>h);r??(r=z);const i=n(r(this.pattern),"regexp"),u=n(r(this.options),"regexp");return`new BSONRegExp(${i}, ${u})`}},re=class extends F{get _bsontype(){return"BSONSymbol"}constructor(e){super(),this.value=e}valueOf(){return this.value}toString(){return this.value}toJSON(){return this.value}toExtendedJSON(){return{$symbol:this.value}}static fromExtendedJSON(e){return new re(e.$symbol)}inspect(e,t,r){return r??(r=z),`new BSONSymbol(${r(this.value,t)})`}};const jn=s;C=class extends jn{get _bsontype(){return"Timestamp"}constructor(e){if(e==null)super(0,0,!0);else if(typeof e=="bigint")super(e,!0);else if(s.isLong(e))super(e.low,e.high,!0);else if(typeof e=="object"&&"t"in e&&"i"in e){if(typeof e.t!="number"&&(typeof e.t!="object"||e.t._bsontype!=="Int32"))throw new a("Timestamp constructed from { t, i } must provide t as a number");if(typeof e.i!="number"&&(typeof e.i!="object"||e.i._bsontype!=="Int32"))throw new a("Timestamp constructed from { t, i } must provide i as a number");const t=Number(e.t),r=Number(e.i);if(t<0||Number.isNaN(t))throw new a("Timestamp constructed from { t, i } must provide a positive t");if(r<0||Number.isNaN(r))throw new a("Timestamp constructed from { t, i } must provide a positive i");if(t>4294967295)throw new a("Timestamp constructed from { t, i } must provide t equal or less than uint32 max");if(r>4294967295)throw new a("Timestamp constructed from { t, i } must provide i equal or less than uint32 max");super(r,t,!0)}else throw new a("A Timestamp can only be constructed with: bigint, Long, or { t: number; i: number }")}toJSON(){return{$timestamp:this.toString()}}static fromInt(e){return new C(s.fromInt(e,!0))}static fromNumber(e){return new C(s.fromNumber(e,!0))}static fromBits(e,t){return new C({i:e,t})}static fromString(e,t){return new C(s.fromString(e,!0,t))}toExtendedJSON(){return{$timestamp:{t:this.high>>>0,i:this.low>>>0}}}static fromExtendedJSON(e){const t=s.isLong(e.$timestamp.i)?e.$timestamp.i.getLowBitsUnsigned():e.$timestamp.i,r=s.isLong(e.$timestamp.t)?e.$timestamp.t.getLowBitsUnsigned():e.$timestamp.t;return new C({t:r,i:t})}inspect(e,t,r){r??(r=z);const n=r(this.high>>>0,t),i=r(this.low>>>0,t);return`new Timestamp({ t: ${n}, i: ${i} })`}},C.MAX_VALUE=s.MAX_UNSIGNED_VALUE;const An=s.fromNumber(ze),Rn=s.fromNumber(Me);function Gt(e,t,r){t=t??{};const n=t&&t.index?t.index:0,i=S.getInt32LE(e,n);if(i<5)throw new a(`bson size must be >= 5, is ${i}`);if(t.allowObjectSmallerThanBufferSize&&e.length<i)throw new a(`buffer length ${e.length} must be >= bson size ${i}`);if(!t.allowObjectSmallerThanBufferSize&&e.length!==i)throw new a(`buffer length ${e.length} must === bson size ${i}`);if(i+n>e.byteLength)throw new a(`(bson size ${i} + options.index ${n} must be <= buffer length ${e.byteLength})`);if(e[n+i-1]!==0)throw new a("One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00");return ve(e,n,t,r)}const Dn=/^\$ref$|^\$id$|^\$db$/;function ve(e,t,r,n=!1){const i=r.fieldsAsRaw==null?null:r.fieldsAsRaw,u=r.raw==null?!1:r.raw,h=typeof r.bsonRegExp=="boolean"?r.bsonRegExp:!1,m=r.promoteBuffers??!1,o=r.promoteLongs??!0,p=r.promoteValues??!0,c=r.useBigInt64??!1;if(c&&!p)throw new a("Must either request bigint or Long for int64 deserialization");if(c&&!o)throw new a("Must either request bigint or Long for int64 deserialization");const l=r.validation==null?{utf8:!0}:r.validation;let g=!0,E,b;const x=l.utf8;if(typeof x=="boolean")E=x;else{g=!1;const $=Object.keys(x).map(function(w){return x[w]});if($.length===0)throw new a("UTF-8 validation setting cannot be empty");if(typeof $[0]!="boolean")throw new a("Invalid UTF-8 validation option, must specify boolean values");if(E=$[0],!$.every(w=>w===E))throw new a("Invalid UTF-8 validation option - keys must be all true or all false")}if(!g){b=new Set;for(const $ of Object.keys(x))b.add($)}const A=t;if(e.length<5)throw new a("corrupt bson message < 5 bytes long");const v=S.getInt32LE(e,t);if(t+=4,v<5||v>e.length)throw new a("corrupt bson message");const L=n?[]:{};let N=0;const X=!1;let Ne=n?!1:null;for(;!X;){const $=e[t++];if($===0)break;let w=t;for(;e[w]!==0&&w<e.length;)w++;if(w>=e.byteLength)throw new a("Bad BSON Document: illegal CString");const I=n?N++:f.toUTF8(e,t,w,!1);let T=!0;g||b!=null&&b.has(I)?T=E:T=!E,Ne!==!1&&I[0]==="$"&&(Ne=Dn.test(I));let y;if(t=w+1,$===Je){const d=S.getInt32LE(e,t);if(t+=4,d<=0||d>e.length-t||e[t+d-1]!==0)throw new a("bad string length in bson");y=f.toUTF8(e,t,t+d-1,T),t=t+d}else if($===Ce){const d=f.allocateUnsafe(12);for(let B=0;B<12;B++)d[B]=e[t+B];y=new j(d),t=t+12}else if($===ce&&p===!1)y=new Z(S.getInt32LE(e,t)),t+=4;else if($===ce)y=S.getInt32LE(e,t),t+=4;else if($===xe)y=S.getFloat64LE(e,t),t+=8,p===!1&&(y=new V(y));else if($===qe){const d=S.getInt32LE(e,t),B=S.getInt32LE(e,t+4);t+=8,y=new Date(new s(d,B).toNumber())}else if($===He){if(e[t]!==0&&e[t]!==1)throw new a("illegal boolean type value");y=e[t++]===1}else if($===$e){const d=t,B=S.getInt32LE(e,t);if(B<=0||B>e.length-t)throw new a("bad embedded document length in bson");if(u)y=e.slice(t,t+B);else{let O=r;g||(O={...r,validation:{utf8:T}}),y=ve(e,d,O,!1)}t=t+B}else if($===Ve){const d=t,B=S.getInt32LE(e,t);let O=r;const Ee=t+B;if(i&&i[I]&&(O={...r,raw:!0}),g||(O={...O,validation:{utf8:T}}),y=ve(e,d,O,!0),t=t+B,e[t-1]!==0)throw new a("invalid array terminator byte");if(t!==Ee)throw new a("corrupted array bson")}else if($===_t)y=void 0;else if($===_e)y=null;else if($===Ue)if(c)y=S.getBigInt64LE(e,t),t+=8;else{const d=S.getInt32LE(e,t),B=S.getInt32LE(e,t+4);t+=8;const O=new s(d,B);o&&p===!0?y=O.lessThanOrEqual(An)&&O.greaterThanOrEqual(Rn)?O.toNumber():O:y=O}else if($===Ze){const d=f.allocateUnsafe(16);for(let B=0;B<16;B++)d[B]=e[t+B];t=t+16,y=new D(d)}else if($===Ie){let d=S.getInt32LE(e,t);t+=4;const B=d,O=e[t++];if(d<0)throw new a("Negative binary type element size found");if(d>e.byteLength)throw new a("Binary type size larger than document size");if(e.slice!=null){if(O===_.SUBTYPE_BYTE_ARRAY){if(d=S.getInt32LE(e,t),t+=4,d<0)throw new a("Negative binary type element size found for subtype 0x02");if(d>B-4)throw new a("Binary type with subtype 0x02 contains too long binary size");if(d<B-4)throw new a("Binary type with subtype 0x02 contains too short binary size")}m&&p?y=f.toLocalBufferType(e.slice(t,t+d)):(y=new _(e.slice(t,t+d),O),O===de&&R.isValid(y)&&(y=y.toUUID()))}else{if(O===_.SUBTYPE_BYTE_ARRAY){if(d=S.getInt32LE(e,t),t+=4,d<0)throw new a("Negative binary type element size found for subtype 0x02");if(d>B-4)throw new a("Binary type with subtype 0x02 contains too long binary size");if(d<B-4)throw new a("Binary type with subtype 0x02 contains too short binary size")}if(m&&p)for(y=f.allocateUnsafe(d),w=0;w<d;w++)y[w]=e[t+w];else y=new _(e.slice(t,t+d),O),O===de&&R.isValid(y)&&(y=y.toUUID())}t=t+d}else if($===pe&&h===!1){for(w=t;e[w]!==0&&w<e.length;)w++;if(w>=e.length)throw new a("Bad BSON Document: illegal CString");const d=f.toUTF8(e,t,w,!1);for(t=w+1,w=t;e[w]!==0&&w<e.length;)w++;if(w>=e.length)throw new a("Bad BSON Document: illegal CString");const B=f.toUTF8(e,t,w,!1);t=w+1;const O=new Array(B.length);for(w=0;w<B.length;w++)switch(B[w]){case"m":O[w]="m";break;case"s":O[w]="g";break;case"i":O[w]="i";break}y=new RegExp(d,O.join(""))}else if($===pe&&h===!0){for(w=t;e[w]!==0&&w<e.length;)w++;if(w>=e.length)throw new a("Bad BSON Document: illegal CString");const d=f.toUTF8(e,t,w,!1);for(t=w+1,w=t;e[w]!==0&&w<e.length;)w++;if(w>=e.length)throw new a("Bad BSON Document: illegal CString");const B=f.toUTF8(e,t,w,!1);t=w+1,y=new J(d,B)}else if($===ke){const d=S.getInt32LE(e,t);if(t+=4,d<=0||d>e.length-t||e[t+d-1]!==0)throw new a("bad string length in bson");const B=f.toUTF8(e,t,t+d-1,T);y=p?B:new re(B),t=t+d}else if($===Ye)y=new C({i:S.getUint32LE(e,t),t:S.getUint32LE(e,t+4)}),t+=8;else if($===Ke)y=new oe;else if($===We)y=new ie;else if($===Le){const d=S.getInt32LE(e,t);if(t+=4,d<=0||d>e.length-t||e[t+d-1]!==0)throw new a("bad string length in bson");const B=f.toUTF8(e,t,t+d-1,T);y=new Y(B),t=t+d}else if($===Pe){const d=S.getInt32LE(e,t);if(t+=4,d<13)throw new a("code_w_scope total size shorter minimum expected length");const B=S.getInt32LE(e,t);if(t+=4,B<=0||B>e.length-t||e[t+B-1]!==0)throw new a("bad string length in bson");const O=f.toUTF8(e,t,t+B-1,T);t=t+B;const Ee=t,Q=S.getInt32LE(e,t),Pn=ve(e,Ee,r,!1);if(t=t+Q,d<8+Q+B)throw new a("code_w_scope total size is too short, truncating scope");if(d>8+Q+B)throw new a("code_w_scope total size is too long, clips outer document");y=new Y(O,Pn)}else if($===Lt){const d=S.getInt32LE(e,t);if(t+=4,d<=0||d>e.length-t||e[t+d-1]!==0)throw new a("bad string length in bson");const B=f.toUTF8(e,t,t+d-1,T);t=t+d;const O=f.allocateUnsafe(12);for(let Q=0;Q<12;Q++)O[Q]=e[t+Q];const Ee=new j(O);t=t+12,y=new k(B,Ee)}else throw new a(`Detected unknown BSON type ${$.toString(16)} for fieldname "${I}"`);I==="__proto__"?Object.defineProperty(L,I,{value:y,writable:!0,enumerable:!0,configurable:!0}):L[I]=y}if(v!==t-A)throw n?new a("corrupt array bson"):new a("corrupt object bson");if(!Ne)return L;if(Dt(L)){const $=Object.assign({},L);return delete $.$ref,delete $.$id,delete $.$db,new k(L.$ref,L.$id,L.$db,$)}return L}const je=/\x00/,Xt=new Set(["$db","$ref","$id","$clusterTime"]);function Qe(e,t,r,n){e[n++]=Je;const i=f.encodeUTF8Into(e,t,n);n=n+i+1,e[n-1]=0;const u=f.encodeUTF8Into(e,r,n+4);return S.setInt32LE(e,n,u+1),n=n+4+u,e[n++]=0,n}function et(e,t,r,n){const i=!Object.is(r,-0)&&Number.isSafeInteger(r)&&r<=ae&&r>=he?ce:xe;e[n++]=i;const u=f.encodeUTF8Into(e,t,n);return n=n+u,e[n++]=0,i===ce?n+=S.setInt32LE(e,n,r):n+=S.setFloat64LE(e,n,r),n}function tt(e,t,r,n){e[n++]=Ue;const i=f.encodeUTF8Into(e,t,n);return n+=i,e[n++]=0,n+=S.setBigInt64LE(e,n,r),n}function Be(e,t,r,n){e[n++]=_e;const i=f.encodeUTF8Into(e,t,n);return n=n+i,e[n++]=0,n}function nt(e,t,r,n){e[n++]=He;const i=f.encodeUTF8Into(e,t,n);return n=n+i,e[n++]=0,e[n++]=r?1:0,n}function rt(e,t,r,n){e[n++]=qe;const i=f.encodeUTF8Into(e,t,n);n=n+i,e[n++]=0;const u=s.fromNumber(r.getTime()),h=u.getLowBits(),m=u.getHighBits();return n+=S.setInt32LE(e,n,h),n+=S.setInt32LE(e,n,m),n}function it(e,t,r,n){e[n++]=pe;const i=f.encodeUTF8Into(e,t,n);if(n=n+i,e[n++]=0,r.source&&r.source.match(je)!=null)throw new a("value "+r.source+" must not contain null bytes");return n=n+f.encodeUTF8Into(e,r.source,n),e[n++]=0,r.ignoreCase&&(e[n++]=105),r.global&&(e[n++]=115),r.multiline&&(e[n++]=109),e[n++]=0,n}function ot(e,t,r,n){e[n++]=pe;const i=f.encodeUTF8Into(e,t,n);if(n=n+i,e[n++]=0,r.pattern.match(je)!=null)throw new a("pattern "+r.pattern+" must not contain null bytes");n=n+f.encodeUTF8Into(e,r.pattern,n),e[n++]=0;const u=r.options.split("").sort().join("");return n=n+f.encodeUTF8Into(e,u,n),e[n++]=0,n}function st(e,t,r,n){r===null?e[n++]=_e:r._bsontype==="MinKey"?e[n++]=Ke:e[n++]=We;const i=f.encodeUTF8Into(e,t,n);return n=n+i,e[n++]=0,n}function ut(e,t,r,n){e[n++]=Ce;const i=f.encodeUTF8Into(e,t,n);return n=n+i,e[n++]=0,n+=r.serializeInto(e,n),n}function ft(e,t,r,n){e[n++]=Ie;const i=f.encodeUTF8Into(e,t,n);n=n+i,e[n++]=0;const u=r.length;if(n+=S.setInt32LE(e,n,u),e[n++]=Ut,u<=16)for(let h=0;h<u;h++)e[n+h]=r[h];else e.set(r,n);return n=n+u,n}function lt(e,t,r,n,i,u,h,m,o){if(o.has(r))throw new a("Cannot convert circular structure to BSON");o.add(r),e[n++]=Array.isArray(r)?Ve:$e;const p=f.encodeUTF8Into(e,t,n);n=n+p,e[n++]=0;const c=Se(e,r,i,n,u+1,h,m,o);return o.delete(r),c}function at(e,t,r,n){e[n++]=Ze;const i=f.encodeUTF8Into(e,t,n);n=n+i,e[n++]=0;for(let u=0;u<16;u++)e[n+u]=r.bytes[u];return n+16}function ht(e,t,r,n){e[n++]=r._bsontype==="Long"?Ue:Ye;const i=f.encodeUTF8Into(e,t,n);n=n+i,e[n++]=0;const u=r.getLowBits(),h=r.getHighBits();return n+=S.setInt32LE(e,n,u),n+=S.setInt32LE(e,n,h),n}function ct(e,t,r,n){r=r.valueOf(),e[n++]=ce;const i=f.encodeUTF8Into(e,t,n);return n=n+i,e[n++]=0,n+=S.setInt32LE(e,n,r),n}function gt(e,t,r,n){e[n++]=xe;const i=f.encodeUTF8Into(e,t,n);return n=n+i,e[n++]=0,n+=S.setFloat64LE(e,n,r.value),n}function bt(e,t,r,n){e[n++]=Le;const i=f.encodeUTF8Into(e,t,n);n=n+i,e[n++]=0;const u=r.toString(),h=f.encodeUTF8Into(e,u,n+4)+1;return S.setInt32LE(e,n,h),n=n+4+h-1,e[n++]=0,n}function mt(e,t,r,n,i=!1,u=0,h=!1,m=!0,o){if(r.scope&&typeof r.scope=="object"){e[n++]=Pe;const p=f.encodeUTF8Into(e,t,n);n=n+p,e[n++]=0;let c=n;const l=r.code;n=n+4;const g=f.encodeUTF8Into(e,l,n+4)+1;S.setInt32LE(e,n,g),e[n+4+g-1]=0,n=n+g+4;const E=Se(e,r.scope,i,n,u+1,h,m,o);n=E-1;const b=E-c;c+=S.setInt32LE(e,c,b),e[n++]=0}else{e[n++]=Le;const p=f.encodeUTF8Into(e,t,n);n=n+p,e[n++]=0;const c=r.code.toString(),l=f.encodeUTF8Into(e,c,n+4)+1;S.setInt32LE(e,n,l),n=n+4+l-1,e[n++]=0}return n}function pt(e,t,r,n){e[n++]=Ie;const i=f.encodeUTF8Into(e,t,n);n=n+i,e[n++]=0;const u=r.buffer;let h=r.position;if(r.sub_type===_.SUBTYPE_BYTE_ARRAY&&(h=h+4),n+=S.setInt32LE(e,n,h),e[n++]=r.sub_type,r.sub_type===_.SUBTYPE_BYTE_ARRAY&&(h=h-4,n+=S.setInt32LE(e,n,h)),h<=16)for(let m=0;m<h;m++)e[n+m]=u[m];else e.set(u,n);return n=n+r.position,n}function dt(e,t,r,n){e[n++]=ke;const i=f.encodeUTF8Into(e,t,n);n=n+i,e[n++]=0;const u=f.encodeUTF8Into(e,r.value,n+4)+1;return S.setInt32LE(e,n,u),n=n+4+u-1,e[n++]=0,n}function yt(e,t,r,n,i,u,h){e[n++]=$e;const m=f.encodeUTF8Into(e,t,n);n=n+m,e[n++]=0;let o=n,p={$ref:r.collection||r.namespace,$id:r.oid};r.db!=null&&(p.$db=r.db),p=Object.assign(p,r.fields);const c=Se(e,p,!1,n,i+1,u,!0,h),l=c-o;return o+=S.setInt32LE(e,n,l),c}function Se(e,t,r,n,i,u,h,m){if(m==null){if(t==null)return e[0]=5,e[1]=0,e[2]=0,e[3]=0,e[4]=0,5;if(Array.isArray(t))throw new a("serialize does not support an array as the root input");if(typeof t!="object")throw new a("serialize does not support non-object as the root input");if("_bsontype"in t&&typeof t._bsontype=="string")throw new a("BSON types cannot be serialized as a document");if(le(t)||fe(t)||ue(t)||Ae(t))throw new a("date, regexp, typedarray, and arraybuffer cannot be BSON documents");m=new Set}m.add(t);let o=n+4;if(Array.isArray(t))for(let c=0;c<t.length;c++){const l=`${c}`;let g=t[c];if(typeof(g==null?void 0:g.toBSON)=="function"&&(g=g.toBSON()),typeof g=="string")o=Qe(e,l,g,o);else if(typeof g=="number")o=et(e,l,g,o);else if(typeof g=="bigint")o=tt(e,l,g,o);else if(typeof g=="boolean")o=nt(e,l,g,o);else if(g instanceof Date||le(g))o=rt(e,l,g,o);else if(g===void 0)o=Be(e,l,g,o);else if(g===null)o=Be(e,l,g,o);else if(ue(g))o=ft(e,l,g,o);else if(g instanceof RegExp||fe(g))o=it(e,l,g,o);else if(typeof g=="object"&&g._bsontype==null)o=lt(e,l,g,o,r,i,u,h,m);else{if(typeof g=="object"&&g[Symbol.for("@@mdb.bson.version")]!==K)throw new ee;if(g._bsontype==="ObjectId")o=ut(e,l,g,o);else if(g._bsontype==="Decimal128")o=at(e,l,g,o);else if(g._bsontype==="Long"||g._bsontype==="Timestamp")o=ht(e,l,g,o);else if(g._bsontype==="Double")o=gt(e,l,g,o);else if(typeof g=="function"&&u)o=bt(e,l,g,o);else if(g._bsontype==="Code")o=mt(e,l,g,o,r,i,u,h,m);else if(g._bsontype==="Binary")o=pt(e,l,g,o);else if(g._bsontype==="BSONSymbol")o=dt(e,l,g,o);else if(g._bsontype==="DBRef")o=yt(e,l,g,o,i,u,m);else if(g._bsontype==="BSONRegExp")o=ot(e,l,g,o);else if(g._bsontype==="Int32")o=ct(e,l,g,o);else if(g._bsontype==="MinKey"||g._bsontype==="MaxKey")o=st(e,l,g,o);else if(typeof g._bsontype<"u")throw new a(`Unrecognized or invalid _bsontype: ${String(g._bsontype)}`)}}else if(t instanceof Map||Re(t)){const c=t.entries();let l=!1;for(;!l;){const g=c.next();if(l=!!g.done,l)continue;const E=g.value[0];let b=g.value[1];typeof(b==null?void 0:b.toBSON)=="function"&&(b=b.toBSON());const x=typeof b;if(typeof E=="string"&&!Xt.has(E)){if(E.match(je)!=null)throw new a("key "+E+" must not contain null bytes");if(r){if(E[0]==="$")throw new a("key "+E+" must not start with '$'");if(E.includes("."))throw new a("key "+E+" must not contain '.'")}}if(x==="string")o=Qe(e,E,b,o);else if(x==="number")o=et(e,E,b,o);else if(x==="bigint")o=tt(e,E,b,o);else if(x==="boolean")o=nt(e,E,b,o);else if(b instanceof Date||le(b))o=rt(e,E,b,o);else if(b===null||b===void 0&&h===!1)o=Be(e,E,b,o);else if(ue(b))o=ft(e,E,b,o);else if(b instanceof RegExp||fe(b))o=it(e,E,b,o);else if(x==="object"&&b._bsontype==null)o=lt(e,E,b,o,r,i,u,h,m);else{if(typeof b=="object"&&b[Symbol.for("@@mdb.bson.version")]!==K)throw new ee;if(b._bsontype==="ObjectId")o=ut(e,E,b,o);else if(x==="object"&&b._bsontype==="Decimal128")o=at(e,E,b,o);else if(b._bsontype==="Long"||b._bsontype==="Timestamp")o=ht(e,E,b,o);else if(b._bsontype==="Double")o=gt(e,E,b,o);else if(b._bsontype==="Code")o=mt(e,E,b,o,r,i,u,h,m);else if(typeof b=="function"&&u)o=bt(e,E,b,o);else if(b._bsontype==="Binary")o=pt(e,E,b,o);else if(b._bsontype==="BSONSymbol")o=dt(e,E,b,o);else if(b._bsontype==="DBRef")o=yt(e,E,b,o,i,u,m);else if(b._bsontype==="BSONRegExp")o=ot(e,E,b,o);else if(b._bsontype==="Int32")o=ct(e,E,b,o);else if(b._bsontype==="MinKey"||b._bsontype==="MaxKey")o=st(e,E,b,o);else if(typeof b._bsontype<"u")throw new a(`Unrecognized or invalid _bsontype: ${String(b._bsontype)}`)}}}else{if(typeof(t==null?void 0:t.toBSON)=="function"&&(t=t.toBSON(),t!=null&&typeof t!="object"))throw new a("toBSON function did not return an object");for(const c of Object.keys(t)){let l=t[c];typeof(l==null?void 0:l.toBSON)=="function"&&(l=l.toBSON());const g=typeof l;if(typeof c=="string"&&!Xt.has(c)){if(c.match(je)!=null)throw new a("key "+c+" must not contain null bytes");if(r){if(c[0]==="$")throw new a("key "+c+" must not start with '$'");if(c.includes("."))throw new a("key "+c+" must not contain '.'")}}if(g==="string")o=Qe(e,c,l,o);else if(g==="number")o=et(e,c,l,o);else if(g==="bigint")o=tt(e,c,l,o);else if(g==="boolean")o=nt(e,c,l,o);else if(l instanceof Date||le(l))o=rt(e,c,l,o);else if(l===void 0)h===!1&&(o=Be(e,c,l,o));else if(l===null)o=Be(e,c,l,o);else if(ue(l))o=ft(e,c,l,o);else if(l instanceof RegExp||fe(l))o=it(e,c,l,o);else if(g==="object"&&l._bsontype==null)o=lt(e,c,l,o,r,i,u,h,m);else{if(typeof l=="object"&&l[Symbol.for("@@mdb.bson.version")]!==K)throw new ee;if(l._bsontype==="ObjectId")o=ut(e,c,l,o);else if(g==="object"&&l._bsontype==="Decimal128")o=at(e,c,l,o);else if(l._bsontype==="Long"||l._bsontype==="Timestamp")o=ht(e,c,l,o);else if(l._bsontype==="Double")o=gt(e,c,l,o);else if(l._bsontype==="Code")o=mt(e,c,l,o,r,i,u,h,m);else if(typeof l=="function"&&u)o=bt(e,c,l,o);else if(l._bsontype==="Binary")o=pt(e,c,l,o);else if(l._bsontype==="BSONSymbol")o=dt(e,c,l,o);else if(l._bsontype==="DBRef")o=yt(e,c,l,o,i,u,m);else if(l._bsontype==="BSONRegExp")o=ot(e,c,l,o);else if(l._bsontype==="Int32")o=ct(e,c,l,o);else if(l._bsontype==="MinKey"||l._bsontype==="MaxKey")o=st(e,c,l,o);else if(typeof l._bsontype<"u")throw new a(`Unrecognized or invalid _bsontype: ${String(l._bsontype)}`)}}}m.delete(t),e[o++]=0;const p=o-n;return n+=S.setInt32LE(e,n,p),o}function Fn(e){return e!=null&&typeof e=="object"&&"_bsontype"in e&&typeof e._bsontype=="string"}const zn={$oid:j,$binary:_,$uuid:_,$symbol:re,$numberInt:Z,$numberDecimal:D,$numberDouble:V,$numberLong:s,$minKey:oe,$maxKey:ie,$regex:J,$regularExpression:J,$timestamp:C};function Qt(e,t={}){if(typeof e=="number"){const n=e<=ae&&e>=he,i=e<=De&&e>=Fe;if(t.relaxed||t.legacy)return e;if(Number.isInteger(e)&&!Object.is(e,-0)){if(n)return new Z(e);if(i)return t.useBigInt64?BigInt(e):s.fromNumber(e)}return new V(e)}if(e==null||typeof e!="object")return e;if(e.$undefined)return null;const r=Object.keys(e).filter(n=>n.startsWith("$")&&e[n]!=null);for(let n=0;n<r.length;n++){const i=zn[r[n]];if(i)return i.fromExtendedJSON(e,t)}if(e.$date!=null){const n=e.$date,i=new Date;if(t.legacy)if(typeof n=="number")i.setTime(n);else if(typeof n=="string")i.setTime(Date.parse(n));else if(typeof n=="bigint")i.setTime(Number(n));else throw new Oe(`Unrecognized type for EJSON date: ${typeof n}`);else if(typeof n=="string")i.setTime(Date.parse(n));else if(s.isLong(n))i.setTime(n.toNumber());else if(typeof n=="number"&&t.relaxed)i.setTime(n);else if(typeof n=="bigint")i.setTime(Number(n));else throw new Oe(`Unrecognized type for EJSON date: ${typeof n}`);return i}if(e.$code!=null){const n=Object.assign({},e);return e.$scope&&(n.$scope=Qt(e.$scope)),Y.fromExtendedJSON(e)}if(Dt(e)||e.$dbPointer){const n=e.$ref?e:e.$dbPointer;if(n instanceof k)return n;const i=Object.keys(n).filter(h=>h.startsWith("$"));let u=!0;if(i.forEach(h=>{["$ref","$id","$db"].indexOf(h)===-1&&(u=!1)}),u)return k.fromExtendedJSON(n)}return e}function Mn(e,t){return e.map((r,n)=>{t.seenObjects.push({propertyName:`index ${n}`,obj:null});try{return P(r,t)}finally{t.seenObjects.pop()}})}function en(e){const t=e.toISOString();return e.getUTCMilliseconds()!==0?t:t.slice(0,-5)+"Z"}function P(e,t){if(e instanceof Map||Re(e)){const r=Object.create(null);for(const[n,i]of e){if(typeof n!="string")throw new a("Can only serialize maps with string keys");r[n]=i}return P(r,t)}if((typeof e=="object"||typeof e=="function")&&e!==null){const r=t.seenObjects.findIndex(n=>n.obj===e);if(r!==-1){const n=t.seenObjects.map(c=>c.propertyName),i=n.slice(0,r).map(c=>`${c} -> `).join(""),u=n[r],h=" -> "+n.slice(r+1,n.length-1).map(c=>`${c} -> `).join(""),m=n[n.length-1],o=" ".repeat(i.length+u.length/2),p="-".repeat(h.length+(u.length+m.length)/2-1);throw new a(`Converting circular structure to EJSON:
    ${i}${u}${h}${m}
    ${o}\\${p}/`)}t.seenObjects[t.seenObjects.length-1].obj=e}if(Array.isArray(e))return Mn(e,t);if(e===void 0)return null;if(e instanceof Date||le(e)){const r=e.getTime(),n=r>-1&&r<2534023188e5;return t.legacy?t.relaxed&&n?{$date:e.getTime()}:{$date:en(e)}:t.relaxed&&n?{$date:en(e)}:{$date:{$numberLong:e.getTime().toString()}}}if(typeof e=="number"&&(!t.relaxed||!isFinite(e))){if(Number.isInteger(e)&&!Object.is(e,-0)){if(e>=he&&e<=ae)return{$numberInt:e.toString()};if(e>=Fe&&e<=De)return{$numberLong:e.toString()}}return{$numberDouble:Object.is(e,-0)?"-0.0":e.toString()}}if(typeof e=="bigint")return t.relaxed?Number(BigInt.asIntN(64,e)):{$numberLong:BigInt.asIntN(64,e).toString()};if(e instanceof RegExp||fe(e)){let r=e.flags;if(r===void 0){const n=e.toString().match(/[gimuy]*$/);n&&(r=n[0])}return new J(e.source,r).toExtendedJSON(t)}return e!=null&&typeof e=="object"?Vn(e,t):e}const Jn={Binary:e=>new _(e.value(),e.sub_type),Code:e=>new Y(e.code,e.scope),DBRef:e=>new k(e.collection||e.namespace,e.oid,e.db,e.fields),Decimal128:e=>new D(e.bytes),Double:e=>new V(e.value),Int32:e=>new Z(e.value),Long:e=>s.fromBits(e.low!=null?e.low:e.low_,e.low!=null?e.high:e.high_,e.low!=null?e.unsigned:e.unsigned_),MaxKey:()=>new ie,MinKey:()=>new oe,ObjectId:e=>new j(e),BSONRegExp:e=>new J(e.pattern,e.options),BSONSymbol:e=>new re(e.value),Timestamp:e=>C.fromBits(e.low,e.high)};function Vn(e,t){if(e==null||typeof e!="object")throw new a("not an object instance");const r=e._bsontype;if(typeof r>"u"){const n={};for(const i of Object.keys(e)){t.seenObjects.push({propertyName:i,obj:null});try{const u=P(e[i],t);i==="__proto__"?Object.defineProperty(n,i,{value:u,writable:!0,enumerable:!0,configurable:!0}):n[i]=u}finally{t.seenObjects.pop()}}return n}else{if(e!=null&&typeof e=="object"&&typeof e._bsontype=="string"&&e[Symbol.for("@@mdb.bson.version")]!==K)throw new ee;if(Fn(e)){let n=e;if(typeof n.toExtendedJSON!="function"){const i=Jn[e._bsontype];if(!i)throw new a("Unrecognized or invalid _bsontype: "+e._bsontype);n=i(n)}return r==="Code"&&n.scope?n=new Y(n.code,P(n.scope,t)):r==="DBRef"&&n.oid&&(n=new k(P(n.collection,t),P(n.oid,t),P(n.db,t),P(n.fields,t))),n.toExtendedJSON(t)}else throw new a("_bsontype must be a string, but was: "+typeof r)}}function tn(e,t){const r={useBigInt64:(t==null?void 0:t.useBigInt64)??!1,relaxed:(t==null?void 0:t.relaxed)??!0,legacy:(t==null?void 0:t.legacy)??!1};return JSON.parse(e,(n,i)=>{if(n.indexOf("\0")!==-1)throw new a(`BSON Document field names cannot contain null bytes, found: ${JSON.stringify(n)}`);return Qt(i,r)})}function nn(e,t,r,n){r!=null&&typeof r=="object"&&(n=r,r=0),t!=null&&typeof t=="object"&&!Array.isArray(t)&&(n=t,t=void 0,r=0);const i=Object.assign({relaxed:!0,legacy:!1},n,{seenObjects:[{propertyName:"(root)",obj:null}]}),u=P(e,i);return JSON.stringify(u,t,r)}function Cn(e,t){return t=t||{},JSON.parse(nn(e,t))}function Hn(e,t){return t=t||{},tn(JSON.stringify(e),t)}te=Object.create(null),te.parse=tn,te.stringify=nn,te.serialize=Cn,te.deserialize=Hn,Object.freeze(te);function wt(e,t){try{return S.getNonnegativeInt32LE(e,t)}catch(r){throw new q("BSON size cannot be negative",t,{cause:r})}}function Bt(e,t){let r=t;for(;e[r]!==0;r++);if(r===e.length-1)throw new q("Null terminator not found",t);return r}function qn(e,t=0){if(t??(t=0),e.length<5)throw new q(`Input must be at least 5 bytes, got ${e.length} bytes`,t);const r=wt(e,t);if(r>e.length-t)throw new q(`Parsed documentSize (${r} bytes) does not match input length (${e.length} bytes)`,t);if(e[t+r-1]!==0)throw new q("BSON documents must end in 0x00",t+r);const n=[];let i=t+4;for(;i<=r+t;){const u=e[i];if(i+=1,u===0){if(i-t!==r)throw new q("Invalid 0x00 type byte",i);break}const h=i,m=Bt(e,i)-h;i+=m+1;let o;if(u===1||u===18||u===9||u===17)o=8;else if(u===16)o=4;else if(u===7)o=12;else if(u===19)o=16;else if(u===8)o=1;else if(u===10||u===6||u===127||u===255)o=0;else if(u===11)o=Bt(e,Bt(e,i)+1)+1-i;else if(u===3||u===4||u===15)o=wt(e,i);else if(u===2||u===5||u===12||u===13||u===14)o=wt(e,i)+4,u===5&&(o+=1),u===12&&(o+=12);else throw new q(`Invalid 0x${u.toString(16).padStart(2,"0")} type byte`,i);if(o>r)throw new q("value reports length larger than document",i);n.push([u,h,m,i,o]),i+=o}return n}se=Object.create(null),se.parseToElements=qn,se.ByteUtils=f,se.NumberUtils=S,Object.freeze(se);const rn=1024*1024*17;let G=f.allocate(rn);It=function(e){G.length<e&&(G=f.allocate(e))},xt=function(e,t={}){const r=typeof t.checkKeys=="boolean"?t.checkKeys:!1,n=typeof t.serializeFunctions=="boolean"?t.serializeFunctions:!1,i=typeof t.ignoreUndefined=="boolean"?t.ignoreUndefined:!0,u=typeof t.minInternalBufferSize=="number"?t.minInternalBufferSize:rn;G.length<u&&(G=f.allocate(u));const h=Se(G,e,r,0,0,n,i,null),m=f.allocateUnsafe(h);return m.set(G.subarray(0,h),0),m},$t=function(e,t,r={}){const n=typeof r.checkKeys=="boolean"?r.checkKeys:!1,i=typeof r.serializeFunctions=="boolean"?r.serializeFunctions:!1,u=typeof r.ignoreUndefined=="boolean"?r.ignoreUndefined:!0,h=typeof r.index=="number"?r.index:0,m=Se(G,e,n,0,0,i,u,null);return t.set(G.subarray(0,m),h),h+m-1},Et=function(e,t={}){return Gt(f.toLocalBufferType(e),t)},Nt=function(e,t={}){t=t||{};const r=typeof t.serializeFunctions=="boolean"?t.serializeFunctions:!1,n=typeof t.ignoreUndefined=="boolean"?t.ignoreUndefined:!0;return Te(e,r,n)},Ot=function(e,t,r,n,i,u){const h=Object.assign({allowObjectSmallerThanBufferSize:!0,index:0},u),m=f.toLocalBufferType(e);let o=t;for(let p=0;p<r;p++){const c=S.getInt32LE(m,o);h.index=o,n[i+p]=Gt(m,h),o=o+c}return o},sn=Object.freeze({__proto__:null,BSONError:a,BSONOffsetError:q,BSONRegExp:J,BSONRuntimeError:Oe,BSONSymbol:re,BSONType:St,BSONValue:F,BSONVersionError:ee,Binary:_,Code:Y,DBRef:k,Decimal128:D,Double:V,EJSON:te,Int32:Z,Long:s,MaxKey:ie,MinKey:oe,ObjectId:j,Timestamp:C,UUID:R,calculateObjectSize:Nt,deserialize:Et,deserializeStream:Ot,onDemand:se,serialize:xt,serializeWithBufferAndIndex:$t,setInternalBufferSize:It});const kn=Object.freeze(Object.defineProperty({__proto__:null},Symbol.toStringTag,{value:"Module"}))});export{sn as BSON,a as BSONError,q as BSONOffsetError,J as BSONRegExp,Oe as BSONRuntimeError,re as BSONSymbol,St as BSONType,F as BSONValue,ee as BSONVersionError,_ as Binary,Y as Code,k as DBRef,D as Decimal128,V as Double,te as EJSON,Z as Int32,s as Long,ie as MaxKey,oe as MinKey,j as ObjectId,C as Timestamp,R as UUID,Kn as __tla,Nt as calculateObjectSize,Et as deserialize,Ot as deserializeStream,se as onDemand,xt as serialize,$t as serializeWithBufferAndIndex,It as setInternalBufferSize};
